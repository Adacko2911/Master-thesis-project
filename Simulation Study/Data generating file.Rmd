---
title: "Multilevel EDHMM Simulation Study: data generation"
author: "Aleksandra Dacko"
date: "10/29/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this file I generate data using Explicit-duration Hidden Markov model. 
The feature I will vary are: 
* mean duration of hidden states,
* number of observations per individual,
* number of hidden states.
```{r}
n<-10 #subjects
n_t<-100 #time series lenght
m<-3
n_dep<-2
# the dependent variable is sadness and the states are depressive, mixed, manic so in depressive state sadness got largest mean
gamma<-matrix(data=c(0.8,0.1,0.1,
                     0.15,0.7,0.15,
                     0.05,0.05,0.9),byrow = T, nrow = m)
#let us assume emission is based on the Groningen data so we treat the 1-100 scale as continuous normally distributed. 
emiss<-list(matrix(data=c(5,1,
                          40,1,
                          65,1), byrow=T,ncol=2,nrow = m),
            matrix(data=c(10,1,
                          15,1,
                          70,1), byrow=T,ncol=2,nrow = m))
gamma_ss_var<-1
emiss_ss_var<-1
gamma[,-1]
```
We want the probabilities from gamma matrix to be expressed in intercept form. Also to present it in a form that the mHMMBayes package output we want the person specific data points to be transformed back to the `m * m` matrix. 
```{r}
int_to_prob<-function(alfa){
  dim<-dim(alfa)
  gamma<-matrix(ncol = dim[2]+1,nrow = dim[1])
  exp_alfa<-exp(alfa)
  exp_alfa<-cbind(rep(1,dim[1]),exp_alfa)
  for(i in 1:dim[1]){
    gamma[i,]<-exp_alfa[i,]/sum(exp_alfa[i,])
  }
  return(round(gamma,4))
}
prob_to_int<-function(gamma){
  gamma<-gamma+0.00001
  if(is.matrix(gamma)){
    dim<-dim(gamma)
    alfa<-matrix(ncol = dim[2]-1,nrow = dim[1])
    for (i in 1:dim[1]) {
      for(k in 2:dim[2]){
        alfa[i,k-1]<-log(gamma[i,k]*(1/gamma[i,1]))
      }
      }
  }
  return(round(alfa,4))
}
#little check if I can recover the same probability matrix
gamma1<-matrix(data=c(0.8,0.1,0.1,
                     0.15,0.7,0.15,
                     0.05,0.05,0.9),byrow = T, nrow = 3)
prob_to_int(gamma1)
new<-prob_to_int(gamma1)
new_gamma<-int_to_prob(new)
new_gamma
new_gamma==gamma1
```
Here I have created the plot function for dwell time duration
```{r, warning=FALSE}
library(ggplot2)
library(RColorBrewer)

plot_lognorm<-function(m, means, sd=2){
  sdlog<-sd
  meanlog<-sort(means)
  col<-brewer.pal(m, name='Dark2')
  data<-density(rlnorm(20000, log(meanlog[1]), log(sdlog)),from=-1,to=150)
  data<-data.frame(x=data$x,y=data$y)
  plot<-ggplot(data=data,aes(x=x,y=y))+geom_line(color=col[1],size=1)+theme_minimal()+ylab("density")+xlab("duration distribution")+ggtitle("State dependent lognormal distribution")+xlim(c(0,100))
  for(s in 2:m){
    data<-density(rlnorm(20000, log(meanlog[s]), log(sdlog)),from=-1,to=150)
    data<-data.frame(x=data$x,y=data$y)
    plot<-plot+geom_line(data=data,aes(x=x,y=y),color=col[s],size=1)
  }
  return(plot)
}

plot_lognorm(m=3,means=c(10,15,40),sd=2.5)

```
We start our simulation 
```{r}
set.seed(1234)
mhsmm_sim<-function(n,n_t,m,n_dep,emiss,gamma,gamma_ss_var,emiss_ss_var){
  #define output lists
  gamma_ss<-rep(list(NULL), n)
  state_sequence<-as.matrix(cbind(rep(1:n, each = n_t),rep(NA,n_t*n)))
  emiss_ss<-rep(list(vector("list", n_dep)), n)
  obv_ss<-cbind(rep(1:n, each = n_t),matrix(rep(NA,n_t*n*n_dep), ncol= n_dep))
  #change the form of a transition matrix
  gamma_int<-prob_to_int(gamma)
  for(subj in 1:n){
    #generate a set of subject specific transition matrices we introduce random subject-specific effect to the intercepts 
    gamma_ss[[subj]]<-int_to_prob(gamma_int+rnorm(n=m*(m-1),mean=0,sd=sqrt(gamma_ss_var)))
    for(dep in 1:n_dep){
      #generate subject specific means of emission distributions of dependent variables,we introduce random subject-specific effect which is deviation from the mean of normally conditionally distributed mean
      emiss_ss[[subj]][[dep]] <- emiss[[dep]]
      emiss_ss[[subj]][[dep]][,1]<-matrix(emiss[[dep]][,1]+rnorm(n=m,mean = 0,sd=sqrt(emiss_ss_var)),nrow=m)
    }
    #now we want to find a starting state to evaluate the state sequence 
    init <- solve(t(diag(m) - gamma_ss[[subj]] + 1), rep(1, m))
    #there were many ways to do so :
    #The approach from here https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
      #A <-  rbind(t(diag(m) - gamma_ss[[subj]]), rep(1, m))
      #b <- c(rep(0, m),1)
      #init <- qr.solve(A, b)
    #the approach with eigonvectors would also work 
      #e <- eigen(t(gamma_ss[[subj]]))$vectors[, 1]
      #e / sum(e)
    
    #for each subject we sample the initial state 
    state_sequence[subj*n_t-n_t+1,2]<-sample(x = 1:m, size = 1, prob = init)
    for(dep in 1:n_dep){
      obv_ss[subj*n_t-n_t+1,dep+1]<-rnorm(n=1,mean=emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+1,2],1],sd=sqrt(emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+1,2],2]) )
    }
    #now we evaluate the rest of the subject specific observations  
    for(t_occ in 2:n_t){
      #states sequen
      state_sequence[subj*n_t-n_t+t_occ,2]<-sample(x = 1:m, size = 1, prob =
                                                     gamma_ss[[subj]][state_sequence[subj*n_t-n_t+t_occ-1,2],])
      #for each subject we sample the mean emission 
      for(dep in 1:n_dep){
      obv_ss[subj*n_t-n_t+t_occ,dep+1]<-rnorm(n=1,mean=emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+t_occ,2],1],sd=sqrt(emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+t_occ,2],2]) )
    }
    }
}
  output<-list(gamma_ss,state_sequence,emiss_ss,obv_ss)
  names(output) <- c("gamma_ss","states", "emiss_ss","observations")
  return(output)
}

mhsmm_sim(n=n,n_t=n_t,m=m,n_dep=n_dep,emiss=emiss,gamma=gamma,gamma_ss_var=gamma_ss_var,emiss_ss_var=emiss_ss_var)

```


Now as we got the first version we want to adjust it such that the model now is going to be HSMM.
First we initiate the input:
```{r}
n<-10 #subjects
n_t<-100 #time series lenght
m<-3
n_dep<-2
# the dependent variable is sadness and the states are depressive, mixed, manic so in depressive state sadness got largest mean
gamma<-matrix(data=c(0,0.9,0.1,
                     0.5,0,0.5,
                     0.2,0.8,0),byrow = T, nrow = m)
#let us assume emission is based on the Groningen data so we treat the 1-100 scale as continuous normally distributed. 
emiss<-list(matrix(data=c(5,1,
                          40,1,
                          65,1), byrow=T,ncol=2,nrow = m),
            matrix(data=c(10,1,
                          15,1,
                          70,1), byrow=T,ncol=2,nrow = m))
gamma_ss_var<-1
emiss_ss_var<-1
dwell_distr<-matrix(data=c(5,2, #first column represent mean and second variance
                          20,2, #need to 
                          30,2), byrow=T,ncol=2,nrow = m)
```

```{r}
set.seed(1234)
mhsmm_sim<-function(n,n_t,m,n_dep,emiss,gamma,gamma_ss_var,emiss_ss_var,dwell_distr){
  #define output lists
  gamma_ss<-rep(list(NULL), n)
  state_sequence<-as.matrix(cbind(rep(1:n, each = n_t),rep(NA,n_t*n)))
  emiss_ss<-rep(list(vector("list", n_dep)), n)
  obv_ss<-cbind(rep(1:n, each = n_t),matrix(rep(NA,n_t*n*n_dep), ncol= n_dep))
  #change the form of a transition matrix
  gamma_int<-prob_to_int(gamma)
  for(subj in 1:n){
    #generate a set of subject specific transition matrices we introduce random subject-specific effect to the intercepts 
    gamma_ss[[subj]]<-int_to_prob(gamma_int+rnorm(n=m*(m-1),mean=0,sd=sqrt(gamma_ss_var))) 
    #the previous step added random effects to all transition matrix entries so we clear once again the diagonal 
    diag(gamma_ss[[subj]])<-rep(0,m)
    for(dep in 1:n_dep){
      #generate subject specific means of emission distributions of dependent variables,we introduce random subject-specific effect which is deviation from the mean of normally conditionally distributed mean
      emiss_ss[[subj]][[dep]] <- emiss[[dep]]
      emiss_ss[[subj]][[dep]][,1]<-matrix(emiss[[dep]][,1]+rnorm(n=m,mean = 0,sd=sqrt(emiss_ss_var)),nrow=m)
    }
    #now we want to find a starting state to evaluate the state sequence 
    init <- solve(t(diag(m) - gamma_ss[[subj]] + 1), rep(1, m))
    #for each subject we sample the initial state 
    state_sequence[subj*n_t-n_t+1,2]<-sample(x = 1:m, size = 1, prob = init)
    for(dep in 1:n_dep){
      obv_ss[subj*n_t-n_t+1,dep+1]<-rnorm(n=1,mean=emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+1,2],1],sd=sqrt(emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+1,2],2]) )
    }
    ak=0
    a=0
    while(ak<n_t){
      #now we evaluate the dwell time based on first state   
      dwell_row<-state_sequence[subj*n_t-n_t+a+1,2]
      mean_dwell<-round(rlnorm(1, log(dwell_distr[dwell_row,1]), log(sqrt(dwell_distr[dwell_row,2]))),0)
      if(a+mean_dwell<n_t){
        state_given_dwell<-rep(dwell_row,mean_dwell-1)
        for (idx in 1:length(state_given_dwell)) {
            state_sequence[subj*n_t-n_t+1+a+idx,2]<-state_given_dwell[idx]
        }
        a<-a+mean_dwell
        state_sequence[subj*n_t-n_t+a+1,2]<-sample(x = 1:m, size = 1, prob =
                                  gamma_ss[[subj]][state_sequence[subj*n_t-n_t+a,2],])
        ak<-a+1
      }else{
        mean_dwell<-n_t-a
        state_given_dwell<-rep(dwell_row,(mean_dwell-1))
        for (idx in 1:length(state_given_dwell)) {
            state_sequence[subj*n_t-n_t+1+a+idx,2]<-state_given_dwell[idx]
        }
        ak<-a+mean_dwell
      }
    }
      #for each subject and each state we sample the mean emission 
      for(t_occ in 2:n_t){
        for(dep in 1:n_dep){
          obv_ss[subj*n_t-n_t+t_occ,dep+1]<-rnorm(n=1,mean=emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+t_occ,2],1],sd=sqrt(emiss_ss[[subj]][[dep]][state_sequence[subj*n_t-n_t+t_occ,2],2]) )
        }
      }
}
  output<-list(gamma_ss,state_sequence,emiss_ss,obv_ss)
  names(output) <- c("gamma_ss","states", "emiss_ss","observations")
  return(output)
}

mhsmm_sim(n=n,n_t=n_t,m=m,n_dep=n_dep,emiss=emiss,gamma=gamma,gamma_ss_var=gamma_ss_var,emiss_ss_var=emiss_ss_var,dwell_distr=dwell_distr)

```

